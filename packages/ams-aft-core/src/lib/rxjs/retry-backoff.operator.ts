import { defer, MonoTypeOperatorFunction, Observable, retry, timer } from 'rxjs';

import { getRandomBetween, getValueOrFn, WithRequired } from '../utils';

/**
 * The internal data generated by retryBackoff.
 */
export interface RetryBackoffData<E extends Error> {
  /**
   * The retryBackoff operator configuration object.
   */
  config: RetryBackoffConfig<E>;
  /**
   * The error that caused the last retry.
   */
  error: E;
  /**
   * The retry attemp number.
   */
  retryCount: number;
  /**
   * The milliseconds since the start of the retries.
   */
  totalTime: number;
  /**
   * The base interval used to calculate the delay.
   */
  baseInterval: number;
}

/**
 * The retryBackoff operator configuration object.
 */
export interface RetryBackoffConfig<E extends Error> {
  /**
   * The maximum number of times to retry.
   * Defaults to 5.
   */
  count?: number;
  /**
   * The initial interval in milliseconds.
   * Defaults to random integer between 300 and 500 ms.
   */
  baseInterval?: number | ((config: RetryBackoffConfig<E>) => number);
  /**
   * Whether or not should resubscribe to the source stream when the source stream errors.
   * Defaults to true.
   */
  shouldRetry?: boolean | ((data: RetryBackoffData<E>) => boolean);
  /**
   * The calculated number of milliseconds to delay before retrying.
   * Defaults to `2^(retryCount-1) * baseInterval`.
   */
  delay?: (data: RetryBackoffData<E>) => number;
  /**
   * Whether or not should not resubscribe to the source stream that should retry.
   * Defaults to false.
   */
  shouldNotRetry?: boolean | ((data: RetryBackoffData<E> & { delay: number }) => boolean);
  /**
   * Perform actions or side-effects that do not affect the retry.
   */
  tap?: (data: RetryBackoffData<E> & { delay: number }) => void;
  /**
   * Whether or not to reset the retry counter when the retried subscription emits its first value.
   * Defaults to false.
   */
  resetOnSuccess?: boolean;
}

/**
 * Returns an Observable that mirrors the source Observable with the exception of an error using a backoff strategy.
 * @param config The RetryBackoffConfig configuration object.
 * @returns A function that returns an Observable that will resubscribe to the
 * source stream when the source stream errors using a backoff strategy.
 * @publicApi
 */
export function retryBackoff<T, E extends Error>(config?: RetryBackoffConfig<E>): MonoTypeOperatorFunction<T> {
  return <T>(source: Observable<T>) => {
    const initiatTime = Date.now();
    const merged: InnerRetryBackoffConfig<E> = {
      count: 5,
      baseInterval,
      shouldRetry: true,
      delay: getExponentialBackoffDelay,
      ...(config ?? {})
    };

    const base = getValueOrFn(merged.baseInterval, merged);

    const delay = (error: E, retryCount: number) => {
      const totalTime = Date.now() - initiatTime;
      const data: RetryBackoffData<E> = {
        error,
        retryCount,
        totalTime,
        config: merged,
        baseInterval: base
      };

      if (!getValueOrFn(merged.shouldRetry, data)) {
        throw error;
      }

      const intervalDelay = merged.delay(data);

      if (intervalDelay <= 0 || getValueOrFn(merged.shouldNotRetry, { delay: intervalDelay, ...data })) {
        throw error;
      }

      if (merged.tap != null) {
        merged.tap({ delay: intervalDelay, ...data });
      }

      return timer(intervalDelay);
    };

    return defer(() => {
      return source.pipe(
        retry({
          delay,
          count: merged.count,
          resetOnSuccess: merged.resetOnSuccess
        })
      );
    });
  };
}

/**
 * @internal
 */
type InnerRetryBackoffConfig<E extends Error> = WithRequired<
  RetryBackoffConfig<E>,
  'baseInterval' | 'shouldRetry' | 'delay'
>;

/**
 * Returns a random integer base interval.
 * @internal
 */
function baseInterval(): number {
  const minInterval = 300;
  const maxInterval = 500;

  return getRandomBetween(minInterval, maxInterval);
}

/**
 * Returns the result of the exponential backoff delay.
 * @param data The internal data generated by retryBackoff.
 * @returns The result of the exponential function.
 */
export function getExponentialBackoffDelay<E extends Error>(
  data: RetryBackoffData<E> & { baseInterval: number }
): number {
  return Math.pow(2, data.retryCount - 1) * data.baseInterval;
}
