import {
  getBackoffDelay,
  parseKeepAliveTimeout,
  parseRetryAfter,
  retryBackoff,
  RetryBackoffConfig,
  RetryBackoffScope,
  SECOND_AS_MILLISECOND
} from '@ams-aft/core';
import { HttpErrorResponse } from '@angular/common/http';
import { MonoTypeOperatorFunction } from 'rxjs';

import { isClientNetworkError } from './is-client-network-error.function';

/**
 * The scope data generated by retryHttpRequest.
 * @publicApi
 */
export type RetryHttpRequestScope = RetryBackoffScope<HttpErrorResponse>;

/**
 * The retryHttpRequest operator configuration object.
 * @publicApi
 */
export interface RetryHttpRequestConfig extends RetryBackoffConfig<HttpErrorResponse> {
  /**
   * The maximum number of times to retry.
   *
   * Defaults to 3.
   */
  count?: number | (() => number);
  /**
   * The number of milliseconds to delay before retrying.
   *
   * Defaults to the value of the Retry-After HTTP header or `baseInterval * 2^(retryCount-1)`.
   */
  delay?: number | ((scope: RetryHttpRequestScope) => number);
  /**
   * Whether or not should resubscribe to the source stream when the source stream errors.
   *
   * Defaults to true if the HttpErrorResponse status is 408, 429, 500, 502, 503 or 504
   * or client connection error. False if the total operation time exceeds the safe maximum
   * of 100s or the value of the Keep-Alive's HTTP header timeout value, whichever is lower.
   */
  shouldRetry?: boolean | ((scope: RetryHttpRequestScope & { delay: number }) => boolean);
  /**
   * Perform actions or side-effects that do not affect the retry.
   */
  tap?: (scope: RetryHttpRequestScope & { delay: number }) => void;
}

/**
 * Retries an HttpClient request when returns an HttpErrorResponse.
 *
 * By default it will retry the failed HTTP request up to 3 times with a delay that increases exponentially
 * between attempts as long as it's a network error or the status is one of the following: 408, 429, 500, 502, 503, 504.
 * It will use the value of the Retry-After HTTP header if exists instead of the backoff,
 * and the Keep-Alive Timeout HTTP header value or 100s, whichever is less, as the operation limit.
 * @param config The RetryHttpRequestConfig configuration object.
 * @returns A function that returns an Angular HTTP Request Observable that will resubscribe to the
 * source when streams an HttpErrorResponse.
 * @publicApi
 * @example
 * ```ts
 * httpClient.get('/resource').pipe(retryHttpRequest()).subscribe()
 * ```
 */
export function retryHttpRequest<T>(config?: RetryHttpRequestConfig): MonoTypeOperatorFunction<T> {
  const merged: RetryHttpRequestConfig = {
    count: 3,
    delay: retryHttpRequestDelay,
    shouldRetry: retryHttpRequestShouldRetry,
    ...(config ?? {})
  };

  return retryBackoff(merged);
}

/**
 * The number of milliseconds to delay before retrying.
 * @param scope The scope data generated by retryHttpRequest.
 * @returns The value of the Retry-After HTTP header, if exists. Otherwise the backoff.
 * @protected
 */
export function retryHttpRequestDelay(scope: RetryHttpRequestScope): number {
  const retryAfter = parseRetryAfter(scope.error.headers.get('Retry-After'));

  return retryAfter ?? getBackoffDelay(scope);
}

/**
 * Checks whether or not should resubscribe to the HTTP request when returns an HttpErrorResponse.
 * @param scope The scope data generated by retryHttpRequest.
 * @returns True if the HttpErrorResponse status is 408, 429, 500, 502, 503 or 504
 * or client connection error. False if the total operation time exceeds the safe maximum
 * of 100s or the value of the Keep-Alive's HTTP header timeout value, whichever is lower.
 * @protected
 */
export function retryHttpRequestShouldRetry(scope: RetryHttpRequestScope & { delay: number }) {
  const maxTime = 100 * SECOND_AS_MILLISECOND;
  const keepAlive = parseKeepAliveTimeout(scope.error.headers.get('Keep-Alive'));
  const maxTotal = keepAlive != null ? Math.min(keepAlive, maxTime) : maxTime;

  const should = [408, 429, 500, 502, 503, 504].includes(scope.error.status) || isClientNetworkError(scope.error);
  const shouldnt = scope.totalTime + scope.delay > maxTotal;

  return should && !shouldnt;
}
