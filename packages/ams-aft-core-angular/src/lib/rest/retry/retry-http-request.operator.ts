import {
  getBackoffDelay,
  parseKeepAliveTimeout,
  parseRetryAfter,
  retryBackoff,
  RetryBackoffConfig,
  RetryBackoffScope,
  SECOND_AS_MILLISECOND
} from '@ams-aft/core';
import { HttpErrorResponse } from '@angular/common/http';
import { MonoTypeOperatorFunction } from 'rxjs';

import { isClientNetworkError } from './is-client-network-error.function';

/**
 * Retries an HttpClient request when returns an HttpErrorResponse.
 *
 * By default it will retry the failed HTTP request up to 3 times with a delay that increases exponentially
 * between attempts as long as it's a network error or the status is one of the following: 408, 429, 500, 502, 503, 504.
 * It will use the value of the Retry-After HTTP header if exists instead of the backoff,
 * and the Keep-Alive Timeout HTTP header value or 100s, whichever is less, as the operation limit.
 * @param config The RetryBackoffConfig configuration object.
 * @returns A function that returns an Angular HTTP Request Observable that will resubscribe to the
 * source when streams an HttpErrorResponse.
 * @see {@link RetryBackoffConfig}
 * @see {@link retryBackoff}
 * @publicApi
 * @example
 * ```ts
 * httpClient.get('/resource').pipe(retryHttpRequest()).subscribe()
 * ```
 */
export function retryHttpRequest<T, E extends HttpErrorResponse>(
  config?: RetryBackoffConfig<E>
): MonoTypeOperatorFunction<T> {
  const merged: RetryBackoffConfig<E> = {
    count: DEFAULT_RETRY_COUNT,
    delay: retryHttpRequestDelay,
    shouldRetry: retryHttpRequestShouldRetry,
    ...(config ?? {})
  };

  return retryBackoff(merged);
}

/**
 * Default safe retry attemps.
 * @publicApi
 */
export const DEFAULT_RETRY_COUNT = 3;

/**
 * Default safe HTTP error codes that should retry.
 * @publicApi
 */
export const DEFAULT_RETRY_HTTP_CODES = [408, 429, 500, 502, 503, 504];

/**
 * Checks whether or not should resubscribe to the HTTP request when returns an HttpErrorResponse.
 * @param scope The scope data generated by retryBackoff.
 * @returns True if the HttpErrorResponse status is in the list of safe HTTP error codes
 * or a client connection error occurs. False if the total operation time exceeds the safe maximum
 * of 100s or the value of the Keep-Alive's HTTP header timeout value, whichever is lower.
 * @see {@link RetryBackoffConfig}
 * @protected
 */
export function retryHttpRequestShouldRetry<E extends HttpErrorResponse>(
  scope: RetryBackoffScope<E> & { delay: number }
) {
  const maxTime = 100 * SECOND_AS_MILLISECOND;
  const keepAlive = parseKeepAliveTimeout(scope.error.headers.get('Keep-Alive'));
  const maxTotal = keepAlive != null ? Math.min(keepAlive, maxTime) : maxTime;

  const shouldRetry = DEFAULT_RETRY_HTTP_CODES.includes(scope.error.status) || isClientNetworkError(scope.error);
  const shouldNotRetry = scope.totalTime + scope.delay > maxTotal;

  return shouldRetry && !shouldNotRetry;
}

/**
 * The number of milliseconds to delay before retrying.
 * @param scope The scope data generated by retryBackoff.
 * @returns The value of the Retry-After HTTP header, if exists. Otherwise the calculated backoff.
 * @see {@link RetryBackoffConfig}
 * @protected
 */
export function retryHttpRequestDelay<E extends HttpErrorResponse>(scope: RetryBackoffScope<E>): number {
  const retryAfter = parseRetryAfter(scope.error.headers.get('Retry-After'));

  return retryAfter ?? getBackoffDelay(scope);
}
