import {
  getBackoffDelay,
  parseKeepAliveTimeout,
  parseRetryAfter,
  RetryBackoffConfigOld,
  retryBackoffOld,
  RetryBackoffScope,
  SECOND_AS_MILLISECOND
} from '@ams-aft/core';
import { HttpErrorResponse } from '@angular/common/http';
import { MonoTypeOperatorFunction } from 'rxjs';

import { isClientNetworkError } from './is-client-network-error.function';

/**
 * The scope data generated by retryHttpRequest.
 * @publicApi
 */
export type RetryHttpRequestScope = RetryBackoffScope<HttpErrorResponse>;

/**
 * The retryHttpRequest operator configuration object.
 * @publicApi
 */
export interface RetryHttpRequestConfig extends RetryBackoffConfigOld<HttpErrorResponse> {
  /**
   * The maximum number of times to retry.
   *
   * Defaults to 3.
   */
  count?: number | (() => number);
  /**
   * The number of milliseconds to delay before retrying.
   *
   * Defaults to the value of the Retry-After HTTP header or `baseInterval * 2^(retryCount-1)`.
   */
  delay?: number | ((scope: RetryHttpRequestScope) => number);
  /**
   * Whether or not should resubscribe to the source stream when the source stream errors.
   *
   * Defaults to true if the HttpErrorResponse status is 408, 429, 500, 502, 503 or 504
   * or client connection error. False if the total operation time exceeds the safe maximum
   * of 100s or the value of the Keep-Alive's HTTP header timeout value, whichever is lower.
   */
  shouldRetry?: boolean | ((scope: RetryHttpRequestScope & { delay: number }) => boolean);
  /**
   * Perform actions or side-effects that do not affect the retry.
   */
  tap?: (scope: RetryHttpRequestScope & { delay: number }) => void;
}

/**
 * Retries an HttpClient request when returns an HttpErrorResponse.
 *
 * By default it will retry the failed HTTP request up to 3 times with a delay that increases exponentially
 * between attempts as long as it's a network error or the status is one of the following: 408, 429, 500, 502, 503, 504.
 * It will use the value of the Retry-After HTTP header if exists instead of the backoff,
 * and the Keep-Alive Timeout HTTP header value or 100s, whichever is less, as the operation limit.
 * @param config The RetryHttpRequestConfig configuration object.
 * @returns A function that returns an Angular HTTP Request Observable that will resubscribe to the
 * source when streams an HttpErrorResponse.
 * @publicApi
 * @example
 * ```ts
 * httpClient.get('/api').pipe(retryHttpRequest())
 * httpClient.get('/api').pipe(retryHttpRequest({ count, baseInterval, delay, shouldRetry, tap }))
 *
 * // Number of retries based on time of day
 * function count(): number {
 *   return Date.now().getHours() <= 6 ? 4 : 2;
 * }
 * // Base interval based on time of day
 * function baseInterval(): number {
 *   return Date.now().getHours() <= 6 ? randomBetween(500, 600) : randomBetween(200, 300);
 * }
 * // Set a maximum delay of 1s if no Retry-After
 * function delay(scope: RetryHttpRequestScope): number {
 *   const retryAfter = parseRetryAfter(scope.error.headers.get('Retry-After'));
 *   return retryAfter ?? Math.min(1_000, getBackoffDelay(scope));
 * }
 * // Retry on timeout errors with a max operation time defined by Keep-Alive or 1s, whichever is lower
 * function shouldRetry(scope: RetryHttpRequestScope & { delay: number }): boolean {
 *    const keepAlive = parseKeepAliveTimeout(scope.error.headers.get('Keep-Alive'));
 *    const maxTotal = keepAlive != null ? Math.min(keepAlive, 1_000) : 1_000;
 *    const should = [408, 504, 524].includes(scope.error.status) || isClientNetworkError(scope.error);
 *    const shouldnt = scope.totalTime + scope.delay > maxTotal;
 *    return should && !shouldnt;
 * }
 * // Log on every retry
 * function tap(scope: RetryHttpRequestScope & { delay: number }) {
 *   console.log(`Retry #${scope.retryCount}`);
 * }
 * ```
 */
export function retryHttpRequest<T>(config?: RetryHttpRequestConfig): MonoTypeOperatorFunction<T> {
  const merged: RetryHttpRequestConfig = {
    count: 3,
    delay: retryHttpRequestDelay,
    shouldRetry: retryHttpRequestShouldRetry,
    ...(config ?? {})
  };

  return retryBackoffOld(merged);
}

/**
 * The number of milliseconds to delay before retrying.
 * @param scope The scope data generated by retryHttpRequest.
 * @returns The value of the Retry-After HTTP header, if exists. Otherwise the backoff.
 * @protected
 */
export function retryHttpRequestDelay(scope: RetryHttpRequestScope): number {
  const retryAfter = parseRetryAfter(scope.error.headers.get('Retry-After'));

  return retryAfter ?? getBackoffDelay(scope);
}

/**
 * Checks whether or not should resubscribe to the HTTP request when returns an HttpErrorResponse.
 * @param scope The scope data generated by retryHttpRequest.
 * @returns True if the HttpErrorResponse status is 408, 429, 500, 502, 503 or 504
 * or client connection error. False if the total operation time exceeds the safe maximum
 * of 100s or the value of the Keep-Alive's HTTP header timeout value, whichever is lower.
 * @protected
 */
export function retryHttpRequestShouldRetry(scope: RetryHttpRequestScope & { delay: number }): boolean {
  const maxTime = 100 * SECOND_AS_MILLISECOND;
  const keepAlive = parseKeepAliveTimeout(scope.error.headers.get('Keep-Alive'));
  const maxTotal = keepAlive != null ? Math.min(keepAlive, maxTime) : maxTime;

  const should = [408, 429, 500, 502, 503, 504].includes(scope.error.status) || isClientNetworkError(scope.error);
  const shouldnt = scope.totalTime + scope.delay > maxTotal;

  return should && !shouldnt;
}
